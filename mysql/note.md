
事务的特性(ACID)

    原子性
        事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
    一致性
        执行事务前后，数据保持一致
    隔离性
        并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
    持久性
        一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
        
并发事务带来的问题

    脏读（Dirty read）
        当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。
        
    丢失修改（Lost to modify）
        指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。
    
    不可重复读（Unrepeatableread）
        指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。
        
    幻读（Phantom read）
        幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
  
事务隔离级别

    READ-UNCOMMITTED(读取未提交)
    
    READ-COMMITTED(读取已提交)
    
    REPEATABLE-READ(可重复读)
    
    SERIALIZABLE(可串行化)

隔离级别 |	脏读 |	不可重复读	 |幻读
---|---|---|---
READ-UNCOMMITTED |	√ |	√ |	√
READ-COMMITTED |	× |	√ |	√
REPEATABLE-READ |	× |	× |	√
SERIALIZABLE |	× |	× |	× 
    
InnoDB 存储引擎在可重复读的隔离级别下，通过Next-key Lock锁算法消除了幻读，使其达到了可串行话的级别
Mysql的存储引擎:

    InnoDB
        
    MyISAM
        性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复
        合适的比如读密集的情况下
    Memory
       
MyISAM和InnoDB的对比

     是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。
     是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。
     是否支持外键： MyISAM不支持，而InnoDB支持。
     是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。

InnoDB存储引擎的锁的算法有三种：

    Record lock：单个行记录上的锁
    Gap lock：间隙锁，锁定一个范围，不包括记录本身
    Next-key lock：record+gap 锁定一个范围，包含记录本身

表级锁和行级锁对比：

    表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。
    行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

索引

    优点：加快数据的检索速度与通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性
    缺点：创建索引和维护索引需要耗费许多时间与占用物理存储空间
索引结构

    哈希索引
        Hash索引指的就是Hash表，最大的优点就是能够在很短的时间内，根据Hash函数定位到数据所在的位置
        Hash索引不支持顺序和范围查询(Hash索引不支持顺序和范围查询
        Hash冲突
        
    B+Tree索引
        只有叶子节点存放 key 和 data，其他内节点只存放key
        叶子节点有一条引用链指向与它相邻的叶子节点
        检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显
        
    B Tree索引
        所有节点既存放 键(key) 也存放 数据(data)
        叶子节点都是独立的
        检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了

索引类型
    
    主键索引
        数据表的主键列使用的就是主键索引，一张数据表有只能有一个主键，并且主键不能为null，不能重复。
        注: 在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。
    
    二级索引（辅助索引）
        二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置
        
        唯一索引(Unique Key)
            唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引
        普通索引(Index) 
            为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和NULL。
        全文索引(Full Text)
            全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术
            Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引
聚集索引与非聚集索引

    聚集索引
        聚集索引即索引结构和数据一起存放的索引，主键索引属于聚集索引。
        在 Mysql 中，InnoDB引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。
        
        查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。
        依赖于有序的数据与更新代价大
    
    非聚集索引
        非聚集索引即索引结构和数据分开存放的索引。二级索引属于非聚集索引。
        MYISAM引擎的表的.MYI文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD文件的数据
        非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据
        
        更新代价比聚集索引要小
        跟聚集索引一样，非聚集索引也依赖于有序的数据；可能会二次查询(回表) 
覆盖索引
    
    如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”
    如主键索引，如果一条SQL需要查询主键，那么正好根据主键索引就可以查到主键。
    再如普通索引，如果一条SQL需要查询name，name字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。
    
索引创建原则
    
    单列索引
    
    联合索引(多列索引)
        创建联合索引时，尽量把查询最频繁的那个字段作为最左(第一个)字段
        
    最左前缀原则

索引创建注意事项

    选择合适的字段
        1.不为NULL的字段
        2.被频繁查询的字段
        3.被作为条件查询的字段
        4.被经常频繁用于连接的字段
        
    不合适创建索引的字段
        1.被频繁更新的字段应该慎重建立索引
        2.不被经常查询的字段没有必要建立索引
        3.尽可能的考虑建立联合索引而不是单列索引
        4.注意避免冗余索引
        5.考虑在字符串类型的字段上使用前缀索引代替普通索引

索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)。
没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 “目录” 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）

Mysql如何为表字段添加索引？？？

    1.添加PRIMARY KEY（主键索引）
    ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
    
    2.添加UNIQUE(唯一索引)
    ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
    
    3.添加INDEX(普通索引)
    ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
    
    4.添加FULLTEXT(全文索引)
    ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
    
    5.添加多列索引
    ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )

索引 | BTREE索引| HASH索引| R-tree索引| Full-text索引
---  | ---      |---      |---        |---|
InnoDB | 支持 | 不支持 | 不支持 | 5.6以后支持
MyISAM | 支持 | 不支持 | 支持   | 支持
Memory | 支持 | 支持   | 不支持 | 不支持


大表优化措施：
    
    1. 限定数据的范围
    2. 读/写分离
    3. 垂直分区
    4. 水平分区